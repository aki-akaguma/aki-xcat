# Design of aki-xcat

## 1. High-Level Architecture

The `aki-xcat` application is designed as a Rust workspace consisting of a binary crate (`aki-xcat`) and a library crate (`libaki-xcat`). This separation adheres to the principle of creating reusable library code and a thin executable wrapper, directly fulfilling acceptance criterion **UC-5**.

- **`libaki-xcat` (Library Crate)**: This crate contains the core logic of the application, including file processing, decompression, and output formatting. It is designed to be completely independent of the command-line interface, allowing its functionality to be embedded in other applications.

- **`aki-xcat` (Binary Crate)**: This crate serves as the entry point for the executable. Its primary responsibilities are:
    1.  Parsing command-line arguments from the operating system.
    2.  Initializing the standard I/O streams (`stdin`, `stdout`, `stderr`).
    3.  Calling the `execute` function in `libaki-xcat` with the parsed arguments.
    4.  Handling top-level errors, printing them to `stderr`, and setting the process exit code.

## 2. Module Design and Data Flow

The application logic is organized into several modules, each with a distinct responsibility. The data flows sequentially through these modules.

### 2.1. `main.rs` (Entry Point)

The process starts here. It captures command-line arguments and passes them to the `libaki-xcat::execute` function. It uses the `runnel` crate to manage I/O streams, which simplifies testing and handling of I/O operations.

### 2.2. `lib.rs` (Library Facade)

This is the main interface of the library. Its `execute` function orchestrates the entire process:

1.  **Configuration Parsing**: It calls `conf::parse_cmdopts` to parse the command-line arguments into a `CmdOptConf` struct. This handles CLI-related criteria (**EV-4, EV-5, UW-4**).
2.  **Execution**: If parsing is successful, it passes the `CmdOptConf` struct to the `run::run` function to execute the main logic.
3.  **Error Handling**: It catches parsing errors and prints help/version messages or returns a generic error.

### 2.3. `conf` Module (Configuration)

- **Responsibility**: This module is dedicated to parsing command-line arguments and creating a configuration object.
- **Implementation**: It uses the `flood-tide` crate to define and parse GNU-style command-line options. The parsed configuration, including flags like `--bin` (**OF-1**), `--number` (**OF-2**), `--file-name` (**OF-3**), and `--path-name` (**OF-4**), is stored in the `CmdOptConf` struct.

### 2.4. `run` Module (Core Logic)

- **Responsibility**: This module contains the core processing logic (**UC-1**).
- **Data Flow**:
    1.  The main `run` function receives the `CmdOptConf` struct.
    2.  It calls `util::adapt_input`, providing it with the list of file paths from the configuration.
    3.  `util::adapt_input` iterates through the inputs and provides a `BufRead` trait object for each one (decompressed, if necessary) to a closure defined in the `run` module.
    4.  This closure, `process_input`, inspects the configuration and dispatches the `BufRead` object to one of three functions:
        - `process_binary`: For binary mode (**OF-1**).
        - `process_text_simple`: For plain text output.
        - `process_text_decorated`: For formatted output with line numbers or file/path names (**OF-2, OF-3, OF-4**).

### 2.5. `util` Module (Utilities)

This module contains several key sub-modules that provide essential services.

#### 2.5.1. `util::file_type` (Decompression Strategy)

- **Responsibility**: This module is responsible for detecting the compression format of a file (**UC-4**).
- **Implementation**: The `detect_file_type` function reads the first four bytes (the "magic numbers") of a file. It then compares these bytes against the known signatures for `gzip`, `xz`, `zstd`, `lz4`, and `bzip2`. If no match is found, it assumes the file is plain text. This design ensures that the application can handle all required formats (**UC-2**, **UC-3**).

#### 2.5.2. `util::adapt_input` (Input Adaptation)

- **Responsibility**: This is the primary input handler, abstracting the source of the data.
- **Implementation**: It iterates through the list of file paths provided by the user.
    - If the list is empty or a path is `-`, it provides a reader for standard input (**EV-2**, **EV-3**).
    - For a regular file path (**EV-1**), it opens the file and calls `util::detect_file_type`.
    - Based on the detected file type, it dynamically wraps the file reader in the appropriate decoder (e.g., `flate2::read::GzDecoder`, `xz2::read::XzDecoder`).
    - It then passes a `Box<dyn BufRead>` (a trait object) to the processing closure in the `run` module. This elegantly handles different input sources and formats with a unified interface.

#### 2.5.3. `util::err` (Error Handling)

- **Responsibility**: This module provides specialized error handling capabilities.
- **Implementation**: It defines a `BrokenPipeError` trait that extends `anyhow::Error`. This allows the main `run` function to specifically check for `std::io::ErrorKind::BrokenPipe` errors and exit gracefully, as required by **UW-3**.

## 3. Error Handling Strategy

The application employs a layered error handling strategy:

- **`anyhow::Result`**: The primary mechanism for propagating errors. Most functions return `anyhow::Result`, which simplifies error handling throughout the call stack. This covers general errors like file not found (**UW-1**) and read/decompression errors (**UW-2**).
- **CLI Errors**: The `conf` module and `lib.rs` handle command-line parsing errors, ensuring that invalid options result in a clear message and a non-zero exit code (**UW-4**).
- **Broken Pipe**: The `run` module specifically checks for broken pipe errors using the trait from `util::err`, ensuring the application can be safely used in shell pipelines (**UW-3**).
